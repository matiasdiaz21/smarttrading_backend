//@version=5
strategy("Auto Trading Estrategy V1", overlay=true, precision=4, max_bars_back=1440, max_lines_count=500, default_qty_type=strategy.percent_of_equity, default_qty_value=100, calc_on_every_tick=true)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üìÇ CONFIGURACI√ìN ORGANIZADA PARA MODIFICACI√ìN F√ÅCIL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Grupo: Configuraci√≥n General
group_general = 'Configuraci√≥n General'
tema = input.string("Oscuro", title="Tema", options=["Oscuro", "Claro"], group=group_general)
i_textSize = input.string("Small", title="Text Size", options=["Tiny", "Small", "Normal", "Large"], group=group_general)
textSize = i_textSize == "Small" ? size.small : i_textSize == "Normal" ? size.normal : i_textSize == "Large" ? size.large : size.tiny
DEC = input.int(5, title="Decimales", minval=0, step=1, group=group_general)
num_ops = input.int(20, title="N√∫mero de operaciones para winrate", minval=1, group=group_general)
tpc = input.bool(true, title="Mostrar zona de profit", group=group_general)
SML_Channel_TF_mins_D_W_M = input.string("400", title="Minutos SML", group=group_general)

// Grupo: Configuraci√≥n de Cuenta / Riesgo
group_cuenta = 'Configuraci√≥n de Cuenta / Riesgo'
capital = input.float(100, title="Capital inicial: USDT üí≤", minval=0, step=0.05, group=group_cuenta)
perdida_ = input.float(1, title="Riesgo asumido (% de cuenta)", minval=0, step=0.05, group=group_cuenta)
comision = input.float(0.08, title="Comisi√≥n Apertura + Cierre (%)", minval=0.01, maxval=0.2, step=0.005, group=group_cuenta)
take_profit = input.float(1.7, title="Ratio Take Profit (RR)", step=0.1, group=group_cuenta)
breakeven_ratio = input.float(0.5, title="Breakeven Ratio (0-1)", minval=0, maxval=1, step=0.05, group=group_cuenta)

// Grupo: Filtros de Estrategia
group_filtros = 'Filtros de Estrategia'
pupupu = input.bool(true, title="Activar Filtro EMA", group=group_filtros)
rsifilter = input.bool(true, title="Activar Filtro RSI", group=group_filtros)
tsr = input.bool(true, title="Activar Pivotes Soporte/Resistencia", group=group_filtros)
use_vol_filter = input.bool(true, title="Activar Filtro de Volatilidad (ATR)", group=group_filtros)
atr_length = input.int(14, title="Per√≠odo ATR", minval=1, group=group_filtros)
atr_sma_length = input.int(50, title="Per√≠odo SMA de ATR", minval=1, group=group_filtros)
atr_multiplier = input.float(1.5, title="Multiplicador ATR para Alta Volatilidad", minval=1.0, step=0.1, group=group_filtros)

// Grupo: Configuraci√≥n EMA
group_ema = 'Configuraci√≥n EMA'
len = input.int(12, minval=1, title="Per√≠odo EMA", group=group_ema)
emacolor = input.color(color.rgb(223, 223, 219), title="Color EMA", group=group_ema)

// Grupo: Configuraci√≥n RSI
group_rsi = 'Configuraci√≥n RSI'
rsiLength = input.int(14, title="Per√≠odo RSI", minval=1, group=group_rsi)
sobrecompra = input.int(70, title="Sobrecompra", group=group_rsi)
sobreventa = input.int(30, title="Sobreventa", group=group_rsi)

// Grupo: Configuraci√≥n MACD (para an√°lisis)
group_macd = 'Configuraci√≥n MACD'
macd_fast = input.int(12, title="MACD Fast Length", group=group_macd)
macd_slow = input.int(26, title="MACD Slow Length", group=group_macd)
macd_signal = input.int(9, title="MACD Signal Length", group=group_macd)

// Grupo: Par√°metros Manuales
group_manual = 'Par√°metros Manuales'
var limit = input.float(0, title="Entrada (Limit)", minval=0, step=0.05, group=group_manual)
var stop = input.float(0, title="Stop Loss üõë", minval=0, step=0.05, group=group_manual)
valid_entry_bars = input.int(10, title="Barras m√°x. esperando retorno a entrada", minval=1, maxval=50, tooltip="Solo se env√≠a ENTRY cuando el precio vuelve a tocar la entrada en las siguientes barras; si no, se cancela la se√±al.", group=group_manual)

// Grupo: RSI en Pantalla (Opcional)
group_rsi_display = 'Mostrar RSI en Gr√°fico'
multifilter = input.string("NONE", title="Activar RSI en Pantalla", tooltip="Muestra RSI en el gr√°fico", options=["NONE", "-RSI-"], group=group_rsi_display)
oscLookbackLength = input.int(200, title="Cantidad de barras a bloquear (Profundidad)", minval=50, maxval=500, step=50, group=group_rsi_display)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üìà C√ÅLCULOS DE INDICADORES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Pivotes
M_HIGH = request.security(syminfo.tickerid, SML_Channel_TF_mins_D_W_M, high, lookahead=barmerge.lookahead_on)
M_LOW = request.security(syminfo.tickerid, SML_Channel_TF_mins_D_W_M, low, lookahead=barmerge.lookahead_on)
M_MED = M_LOW + (M_HIGH - M_LOW) / 2

plot(tsr ? M_HIGH : na, title="Resistencia", color=M_HIGH != M_HIGH[1] ? na : color.rgb(110, 1, 100), style=plot.style_line, linewidth=2)
plot(tsr ? M_LOW : na, title="Soporte", color=M_LOW != M_LOW[1] ? na : color.rgb(110, 1, 100), style=plot.style_line, linewidth=2)
plot(tsr ? M_MED : na, title="50%", color=M_LOW != M_LOW[1] ? na : color.rgb(111, 111, 111), style=plot.style_line, linewidth=1)

// RSI
srcm = close
rsi = ta.rsi(srcm, rsiLength)
sc = multifilter == "-RSI-" ? rsi > sobrecompra : na
sv = multifilter == "-RSI-" ? rsi < sobreventa : na
rsi_alcista = rsi[1] < sobreventa or rsi[2] < sobreventa or rsi[3] < sobreventa or rsi[4] < sobreventa or rsi[5] < sobreventa or rsi[6] < sobreventa or rsi[7] < sobreventa
rsi_bajista = rsi[1] > sobrecompra or rsi[2] > sobrecompra or rsi[3] > sobrecompra or rsi[4] > sobrecompra or rsi[5] > sobrecompra or rsi[6] > sobrecompra or rsi[7] > sobrecompra

// EMA Estrategia
ema1 = ta.ema(close, len)
plot(pupupu ? ema1 : na, color=emacolor, title="EMA Estrategia", linewidth=1, style=plot.style_stepline)

// MACD (para an√°lisis, sin plot)
[macd_line, signal_line, hist] = ta.macd(close, macd_fast, macd_slow, macd_signal)

// Filtro de Volatilidad con ATR
atrValue = ta.atr(atr_length)
atrSMA = ta.sma(atrValue, atr_sma_length)
high_vol = atrValue > atrSMA * atr_multiplier

// Volumen
vol = volume

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ÔøΩ FUNCIONES HELPER PARA MULTI-TIMEFRAME
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Calcular timeframes superiores din√°micamente
int currentTfSeconds = timeframe.in_seconds()
string htf1 = timeframe.from_seconds(currentTfSeconds * 4)  // 4x el timeframe actual
string htf2 = timeframe.from_seconds(currentTfSeconds * 16)  // 16x el timeframe actual
string htf3 = "1D"  // Diario

// Funci√≥n helper para obtener valores MACD individuales (para usar en request.security)
getMACDLine() =>
    [macd_line, _, _] = ta.macd(close, macd_fast, macd_slow, macd_signal)
    macd_line

getMACDSignal() =>
    [_, signal_line, _] = ta.macd(close, macd_fast, macd_slow, macd_signal)
    signal_line

getMACDHist() =>
    [_, _, hist_line] = ta.macd(close, macd_fast, macd_slow, macd_signal)
    hist_line

// Funci√≥n para obtener datos t√©cnicos de un timeframe espec√≠fico
getTimeframeIndicators(string tf) =>
    [rsi_val, macd_line_val, macd_signal_val, macd_hist_val, ema_val, atr_val, vol_val, open_val, high_val, low_val, close_val] = request.security(syminfo.tickerid, tf, [ta.rsi(close, rsiLength), getMACDLine(), getMACDSignal(), getMACDHist(), ta.ema(close, len), ta.atr(atr_length), volume, open, high, low, close], lookahead=barmerge.lookahead_on)

// Funci√≥n para calcular sentimiento de un timeframe
calculateSentiment(float rsi_val, float ema_val, float close_val, float macd_line_val, float macd_signal_val, float macd_hist_val) =>
    bool rsi_bullish = rsi_val > 50 and rsi_val < sobrecompra
    bool rsi_bearish = rsi_val < 50 and rsi_val > sobreventa
    bool rsi_oversold = rsi_val < sobreventa
    bool rsi_overbought = rsi_val > sobrecompra
    bool uptrend_tf = close_val > ema_val
    bool downtrend_tf = close_val < ema_val
    bool macd_bullish_tf = macd_line_val > macd_signal_val and macd_hist_val > 0
    bool macd_bearish_tf = macd_line_val < macd_signal_val and macd_hist_val < 0
    int bullish_score_tf = 0
    int bearish_score_tf = 0
    if rsi_oversold
        bullish_score_tf += 30
    else if rsi_bullish
        bullish_score_tf += 15
    else if rsi_overbought
        bearish_score_tf += 30
    else if rsi_bearish
        bearish_score_tf += 15
    if uptrend_tf
        bullish_score_tf += 40
    else if downtrend_tf
        bearish_score_tf += 40
    if macd_bullish_tf
        bullish_score_tf += 30
    else if macd_bearish_tf
        bearish_score_tf += 30
    string sentiment_result = "NEUTRAL"
    if bullish_score_tf > bearish_score_tf and bullish_score_tf >= 40
        sentiment_result := "ALCISTA"
    else if bearish_score_tf > bullish_score_tf and bearish_score_tf >= 40
        sentiment_result := "BAJISTA"
    [sentiment_result, bullish_score_tf, bearish_score_tf]

// Funci√≥n para calcular tendencia
calculateTrend(float close_val, float ema_val, float close_prev, float ema_prev, float close_prev2, float ema_prev2) =>
    bool uptrend_tf = close_val > ema_val
    bool downtrend_tf = close_val < ema_val
    bool strong_uptrend_tf = close_val > ema_val and close_prev > ema_prev and close_prev2 > ema_prev2
    bool strong_downtrend_tf = close_val < ema_val and close_prev < ema_prev and close_prev2 < ema_prev2
    string direction = "SIDEWAYS"
    string strength = "WEAK"
    if strong_uptrend_tf
        direction := "UP"
        strength := "STRONG"
    else if uptrend_tf
        direction := "UP"
        strength := "MODERATE"
    else if strong_downtrend_tf
        direction := "DOWN"
        strength := "STRONG"
    else if downtrend_tf
        direction := "DOWN"
        strength := "MODERATE"
    [direction, strength]

// Funci√≥n para obtener volumen relativo
getVolumeRelative(float vol_val, string tf) =>
    float vol_avg = request.security(syminfo.tickerid, tf, ta.sma(volume, 20), lookahead=barmerge.lookahead_on)
    float vol_relative = vol_avg > 0 ? (vol_val / vol_avg) * 100 : 100.0
    string vol_state = vol_relative > 120 ? "ABOVE_AVERAGE" : vol_relative < 80 ? "BELOW_AVERAGE" : "AVERAGE"
    [vol_relative, vol_state]

// Funci√≥n para obtener ATR relativo
getATRRelative(float atr_val, string tf) =>
    float atr_avg = request.security(syminfo.tickerid, tf, ta.sma(ta.atr(atr_length), 20), lookahead=barmerge.lookahead_on)
    float atr_relative = atr_avg > 0 ? (atr_val / atr_avg) * 100 : 100.0
    string atr_state = atr_relative > 150 ? "HIGH" : atr_relative < 80 ? "LOW" : "NORMAL"
    [atr_relative, atr_state]

// Funci√≥n para construir JSON de timeframe completo
buildTimeframeJSON(string tf_name, string tf_period, float rsi_val, float macd_line_val, float macd_signal_val, float macd_hist_val, float ema_val, float atr_val, float vol_val, float open_val, float high_val, float low_val, float close_val, float close_prev, float ema_prev, float close_prev2, float ema_prev2) =>
    [sentiment_val, bullish_score, bearish_score] = calculateSentiment(rsi_val, ema_val, close_val, macd_line_val, macd_signal_val, macd_hist_val)
    [trend_dir, trend_str] = calculateTrend(close_val, ema_val, close_prev, ema_prev, close_prev2, ema_prev2)
    [vol_rel, vol_state] = getVolumeRelative(vol_val, tf_period)
    [atr_rel, atr_state] = getATRRelative(atr_val, tf_period)
    string rsi_state = rsi_val > sobrecompra ? "OVERBOUGHT" : rsi_val < sobreventa ? "OVERSOLD" : "NEUTRAL"
    string macd_dir = macd_line_val > macd_signal_val and macd_hist_val > 0 ? "BULLISH" : macd_line_val < macd_signal_val and macd_hist_val < 0 ? "BEARISH" : "NEUTRAL"
    string price_ema_rel = close_val > ema_val ? "ABOVE" : "BELOW"
    '"' + tf_name + '": {"timeframe": "' + tf_period + '", "indicators": {"rsi": {"value": ' + str.tostring(rsi_val, "#.##") + ', "state": "' + rsi_state + '"}, "macd": {"line": ' + str.tostring(macd_line_val, "#.####") + ', "signal": ' + str.tostring(macd_signal_val, "#.####") + ', "hist": ' + str.tostring(macd_hist_val, "#.####") + ', "direction": "' + macd_dir + '"}, "ema": {"value": ' + str.tostring(ema_val, "#.####") + ', "priceRelation": "' + price_ema_rel + '"}, "atr": {"value": ' + str.tostring(atr_val, "#.####") + ', "relative": ' + str.tostring(atr_rel, "#.##") + ', "state": "' + atr_state + '"}}, "ohlc": {"open": ' + str.tostring(open_val, "#.####") + ', "high": ' + str.tostring(high_val, "#.####") + ', "low": ' + str.tostring(low_val, "#.####") + ', "close": ' + str.tostring(close_val, "#.####") + '}, "volume": {"value": ' + str.tostring(vol_val, "#.##") + ', "relative": ' + str.tostring(vol_rel, "#.##") + ', "state": "' + vol_state + '"}, "sentiment": {"value": "' + sentiment_val + '", "score": {"bullish": ' + str.tostring(bullish_score) + ', "bearish": ' + str.tostring(bearish_score) + '}}, "trend": {"direction": "' + trend_dir + '", "strength": "' + trend_str + '"}}'

// Funci√≥n para construir JSON completo de todos los timeframes y contexto de mercado
buildMultiTimeframeJSON() =>
    string current_tf = timeframe.period
    float current_close_prev = close[1]
    float current_ema_prev = ema1[1]
    float current_close_prev2 = close[2]
    float current_ema_prev2 = ema1[2]
    string current_json = buildTimeframeJSON("current", current_tf, rsi, macd_line, signal_line, hist, ema1, atrValue, vol, open, high, low, close, current_close_prev, current_ema_prev, current_close_prev2, current_ema_prev2)
    [htf1_rsi, htf1_macd_line, htf1_macd_signal, htf1_macd_hist, htf1_ema, htf1_atr, htf1_vol, htf1_open, htf1_high, htf1_low, htf1_close] = getTimeframeIndicators(htf1)
    float htf1_close_prev = request.security(syminfo.tickerid, htf1, close[1], lookahead=barmerge.lookahead_on)
    float htf1_ema_prev = request.security(syminfo.tickerid, htf1, ta.ema(close, len)[1], lookahead=barmerge.lookahead_on)
    float htf1_close_prev2 = request.security(syminfo.tickerid, htf1, close[2], lookahead=barmerge.lookahead_on)
    float htf1_ema_prev2 = request.security(syminfo.tickerid, htf1, ta.ema(close, len)[2], lookahead=barmerge.lookahead_on)
    string htf1_json = buildTimeframeJSON("htf1", htf1, htf1_rsi, htf1_macd_line, htf1_macd_signal, htf1_macd_hist, htf1_ema, htf1_atr, htf1_vol, htf1_open, htf1_high, htf1_low, htf1_close, htf1_close_prev, htf1_ema_prev, htf1_close_prev2, htf1_ema_prev2)
    [htf2_rsi, htf2_macd_line, htf2_macd_signal, htf2_macd_hist, htf2_ema, htf2_atr, htf2_vol, htf2_open, htf2_high, htf2_low, htf2_close] = getTimeframeIndicators(htf2)
    float htf2_close_prev = request.security(syminfo.tickerid, htf2, close[1], lookahead=barmerge.lookahead_on)
    float htf2_ema_prev = request.security(syminfo.tickerid, htf2, ta.ema(close, len)[1], lookahead=barmerge.lookahead_on)
    float htf2_close_prev2 = request.security(syminfo.tickerid, htf2, close[2], lookahead=barmerge.lookahead_on)
    float htf2_ema_prev2 = request.security(syminfo.tickerid, htf2, ta.ema(close, len)[2], lookahead=barmerge.lookahead_on)
    string htf2_json = buildTimeframeJSON("htf2", htf2, htf2_rsi, htf2_macd_line, htf2_macd_signal, htf2_macd_hist, htf2_ema, htf2_atr, htf2_vol, htf2_open, htf2_high, htf2_low, htf2_close, htf2_close_prev, htf2_ema_prev, htf2_close_prev2, htf2_ema_prev2)
    [htf3_rsi, htf3_macd_line, htf3_macd_signal, htf3_macd_hist, htf3_ema, htf3_atr, htf3_vol, htf3_open, htf3_high, htf3_low, htf3_close] = getTimeframeIndicators(htf3)
    float htf3_close_prev = request.security(syminfo.tickerid, htf3, close[1], lookahead=barmerge.lookahead_on)
    float htf3_ema_prev = request.security(syminfo.tickerid, htf3, ta.ema(close, len)[1], lookahead=barmerge.lookahead_on)
    float htf3_close_prev2 = request.security(syminfo.tickerid, htf3, close[2], lookahead=barmerge.lookahead_on)
    float htf3_ema_prev2 = request.security(syminfo.tickerid, htf3, ta.ema(close, len)[2], lookahead=barmerge.lookahead_on)
    string htf3_json = buildTimeframeJSON("htf3", htf3, htf3_rsi, htf3_macd_line, htf3_macd_signal, htf3_macd_hist, htf3_ema, htf3_atr, htf3_vol, htf3_open, htf3_high, htf3_low, htf3_close, htf3_close_prev, htf3_ema_prev, htf3_close_prev2, htf3_ema_prev2)
    [atr_rel_global, atr_state_global] = getATRRelative(atrValue, current_tf)
    [vol_rel_global, vol_state_global] = getVolumeRelative(vol, current_tf)
    float dist_to_support = close - M_LOW
    float dist_to_resistance = M_HIGH - close
    float range_size = M_HIGH - M_LOW
    float position_in_range = range_size > 0 ? ((close - M_LOW) / range_size) * 100 : 50.0
    string position_state = position_in_range > 70 ? "NEAR_RESISTANCE" : position_in_range < 30 ? "NEAR_SUPPORT" : "MID_RANGE"
    string market_context = '"marketContext": {"volatility": {"atrRelative": ' + str.tostring(atr_rel_global, "#.##") + ', "state": "' + atr_state_global + '"}, "volume": {"relative": ' + str.tostring(vol_rel_global, "#.##") + ', "state": "' + vol_state_global + '"}, "supportResistance": {"distanceToSupport": ' + str.tostring(dist_to_support, "#.####") + ', "distanceToResistance": ' + str.tostring(dist_to_resistance, "#.####") + ', "positionInRange": ' + str.tostring(position_in_range, "#.##") + ', "state": "' + position_state + '"}}'
    '"timeframes": {' + current_json + ', ' + htf1_json + ', ' + htf2_json + ', ' + htf3_json + '}, ' + market_context

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ÔøΩ CONDICIONES DE ENTRADA/SALIDA
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Condiciones de soporte y resistencia
soporte = ((low <= M_LOW or low[1] <= M_LOW or low[2] <= M_LOW or low[3] <= M_LOW or low[4] <= M_LOW or low[5] <= M_LOW or low[6] <= M_LOW or low[7] <= M_LOW or low[8] <= M_LOW or low[9] <= M_LOW or low[10] <= M_LOW or low[11] <= M_LOW or low[12] <= M_LOW or low[13] <= M_LOW or low[14] <= M_LOW or low[15] <= M_LOW) and (ta.crossover(close, ema1) and (close[1] < ema1[1]) and (close[2] < ema1[2] and close[3] < ema1[3] and close[4] < ema1[4]) or (low[1] <= M_LOW) or low[2] <= M_LOW) and (ta.crossover(close, ema1)))
resistencia = ((high >= M_HIGH or high[1] >= M_HIGH or high[2] >= M_HIGH or high[3] >= M_HIGH or high[4] >= M_HIGH or high[5] >= M_HIGH or high[6] >= M_HIGH or high[7] >= M_HIGH or high[8] >= M_HIGH or high[9] >= M_HIGH or high[10] >= M_HIGH or high[11] >= M_HIGH or high[12] >= M_HIGH or high[13] >= M_HIGH or high[14] >= M_HIGH or high[15] >= M_HIGH) and (ta.crossunder(close, ema1) and (close[1] > ema1[1]) and (close[2] > ema1[2] and close[3] > ema1[3] and close[4] > ema1[4]) or (high[1] >= M_HIGH) or high[2] >= M_HIGH) and (ta.crossunder(close, ema1)))
filtro_long = ema1 < M_MED
filtro_short = ema1 > M_MED

// Condiciones combinadas con filtro de volatilidad
longcondicion = soporte and (not rsifilter or rsi_alcista) and (macd_line > signal_line and hist > hist[1]) and filtro_long and pupupu and (not use_vol_filter or not high_vol)
shortcondicion = resistencia and (not rsifilter or rsi_bajista) and (macd_line < signal_line and hist < hist[1]) and filtro_short and pupupu and (not use_vol_filter or not high_vol)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üìä L√ìGICA DE ESTRATEGIA
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

var limitl = 0.0
var stopl = 0.0
var tpl = 0.0
var limits = 0.0
var stops = 0.0
var tps = 0.0
var float activeEntry = 0.0
var float activeStop = 0.0
var float activeTp = 0.0
var float breakeven = 0.0
var string op = "na"
var float cien = 0
var bool alert_take_profit_triggered = false
var bool alert_stop_loss_triggered = false
var bool alert_breakeven_triggered = false
var bool isTradeOpen = false
var string activeTradeType = "na"
var int trade_id = 0
var float[] outcomes = array.new_float(0)
var tp = 0.0
// Pendiente: solo enviamos ENTRY cuando el precio vuelve a tocar la entrada en las barras siguientes (operaci√≥n v√°lida)
var bool pendingLong = false
var bool pendingShort = false
var float pendingEntry = 0.0
var float pendingStop = 0.0
var float pendingTp = 0.0
var float pendingBreakeven = 0.0
var int pendingTradeId = 0
var int pendingBarIndex = 0

// 1) Entrada pendiente LONG: precio volvi√≥ a entrada ‚Üí ejecutar ENTRY (alert + orden limit)
if pendingLong and low <= pendingEntry
    limit := pendingEntry
    limitl := pendingEntry
    limits := 0.0
    stop := pendingStop
    stopl := pendingStop
    stops := 0.0
    tp := pendingTp
    tpl := pendingTp
    tps := 0.0
    breakeven := pendingBreakeven
    activeTradeType := "LONG"
    activeEntry := pendingEntry
    activeStop := pendingStop
    activeTp := pendingTp
    alert_take_profit_triggered := false
    alert_stop_loss_triggered := false
    alert_breakeven_triggered := false
    isTradeOpen := true
    trade_id := pendingTradeId
    pendingLong := false
    qty = (perdida_ * capital / 100) / math.abs(pendingEntry - pendingStop)
    strategy.entry("Long", strategy.long, qty=qty, limit=pendingEntry)
    strategy.exit("Exit Long", "Long", stop=pendingStop, limit=pendingTp)
    string multi_tf_json = buildMultiTimeframeJSON()
    alert('{"symbol": "' + syminfo.ticker + '", "side": "LONG", "entryPrice": ' + str.tostring(pendingEntry) + ', "stopLoss": ' + str.tostring(pendingStop) + ', "takeProfit": ' + str.tostring(pendingTp) + ', "breakeven": ' + str.tostring(pendingBreakeven) + ', "alertType": "ENTRY", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(pendingTradeId) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar_close)
    label.new(bar_index, pendingEntry, text="Long Entry\nID: " + str.tostring(pendingTradeId) + "\nBE: " + str.tostring(math.round(pendingBreakeven, 2)), style=label.style_label_up, color=color.green, textcolor=color.white, size=textSize)

if pendingLong and not (low <= pendingEntry)
    if low <= pendingStop
        pendingLong := false
    else if (bar_index - pendingBarIndex) >= valid_entry_bars
        pendingLong := false

// 2) Entrada pendiente SHORT: precio volvi√≥ a entrada ‚Üí ejecutar ENTRY
if pendingShort and high >= pendingEntry
    limit := pendingEntry
    limits := pendingEntry
    limitl := 0.0
    stop := pendingStop
    stops := pendingStop
    stopl := 0.0
    tp := pendingTp
    tps := pendingTp
    tpl := 0.0
    breakeven := pendingBreakeven
    activeTradeType := "SHORT"
    activeEntry := pendingEntry
    activeStop := pendingStop
    activeTp := pendingTp
    alert_take_profit_triggered := false
    alert_stop_loss_triggered := false
    alert_breakeven_triggered := false
    isTradeOpen := true
    trade_id := pendingTradeId
    pendingShort := false
    qty = (perdida_ * capital / 100) / math.abs(pendingStop - pendingEntry)
    strategy.entry("Short", strategy.short, qty=qty, limit=pendingEntry)
    strategy.exit("Exit Short", "Short", stop=pendingStop, limit=pendingTp)
    string multi_tf_json = buildMultiTimeframeJSON()
    alert('{"symbol": "' + syminfo.ticker + '", "side": "SHORT", "entryPrice": ' + str.tostring(pendingEntry) + ', "stopLoss": ' + str.tostring(pendingStop) + ', "takeProfit": ' + str.tostring(pendingTp) + ', "breakeven": ' + str.tostring(pendingBreakeven) + ', "alertType": "ENTRY", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(pendingTradeId) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar_close)
    label.new(bar_index, pendingEntry, text="Short Entry\nID: " + str.tostring(pendingTradeId) + "\nBE: " + str.tostring(math.round(pendingBreakeven, 2)), style=label.style_label_down, color=color.red, textcolor=color.white, size=textSize)

if pendingShort and not (high >= pendingEntry)
    if high >= pendingStop
        pendingShort := false
    else if (bar_index - pendingBarIndex) >= valid_entry_bars
        pendingShort := false

// 3) Nueva se√±al LONG: guardar pendiente (no alert ni orden hasta que precio vuelva a entrada)
if longcondicion and not isTradeOpen and not pendingLong and not pendingShort
    limit := math.round_to_mintick(ema1)
    stop := math.round_to_mintick(M_LOW)
    tp := math.round_to_mintick(limit + (limit - stop) * take_profit)
    pendingLong := true
    pendingEntry := limit
    pendingStop := stop
    pendingTp := tp
    pendingBreakeven := math.round_to_mintick(limit + (tp - limit) * breakeven_ratio)
    pendingTradeId := trade_id + 1
    pendingBarIndex := bar_index
    label.new(bar_index, limit, text="Se√±al Long\nEsperando retorno a " + str.tostring(limit, "#.####"), style=label.style_label_up, color=color.blue, textcolor=color.white, size=textSize)

// 4) Nueva se√±al SHORT: guardar pendiente
if shortcondicion and not isTradeOpen and not pendingLong and not pendingShort
    limit := math.round_to_mintick(ema1)
    stop := math.round_to_mintick(M_HIGH)
    tp := math.round_to_mintick(limit - math.abs(limit - stop) * take_profit)
    pendingShort := true
    pendingEntry := limit
    pendingStop := stop
    pendingTp := tp
    pendingBreakeven := math.round_to_mintick(limit - (limit - tp) * breakeven_ratio)
    pendingTradeId := trade_id + 1
    pendingBarIndex := bar_index
    label.new(bar_index, limit, text="Se√±al Short\nEsperando retorno a " + str.tostring(limit, "#.####"), style=label.style_label_down, color=color.blue, textcolor=color.white, size=textSize)

// Determinar tipo de operaci√≥n
if activeEntry < activeStop and isTradeOpen
    op := "SHORT"
    cien := -1
else if activeEntry > activeStop and isTradeOpen
    op := "LONG"
    cien := 1
else
    op := "na"

// Gesti√≥n de riesgo
diferencia = math.abs(limit - stop)
PORCENTT = (diferencia * 100 / limit) * cien
POSICION = (100 / PORCENTT) * perdida_
LOTE = POSICION / limit
COMI = (comision * POSICION / 100) * -1

// Alertas de Breakeven
if activeTradeType == "LONG" and high >= breakeven and not alert_breakeven_triggered and isTradeOpen
    activeStop := activeEntry
    stopl := activeEntry
    strategy.exit("Exit Long", "Long", stop=activeEntry, limit=activeTp)
    string multi_tf_json = buildMultiTimeframeJSON()
    alert('{"symbol": "' + syminfo.ticker + '", "side": "LONG", "entryPrice": ' + str.tostring(activeEntry) + ', "stopLoss": ' + str.tostring(activeEntry) + ', "takeProfit": ' + str.tostring(activeTp) + ', "breakeven": ' + str.tostring(breakeven) + ', "alertType": "BREAKEVEN", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(trade_id) + ', "mensaje": "Breakeven alcanzado - ' + str.tostring(math.round(breakeven_ratio * 100)) + '% profit, SL movido a entrada", "precio_actual": ' + str.tostring(close) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar)
    alert_breakeven_triggered := true
    label.new(bar_index, close, text="Breakeven\nID: " + str.tostring(trade_id), style=label.style_label_down, color=color.orange, textcolor=color.white, size=textSize)

if activeTradeType == "SHORT" and low <= breakeven and not alert_breakeven_triggered and isTradeOpen
    activeStop := activeEntry
    stops := activeEntry
    strategy.exit("Exit Short", "Short", stop=activeEntry, limit=activeTp)
    string multi_tf_json = buildMultiTimeframeJSON()
    alert('{"symbol": "' + syminfo.ticker + '", "side": "SHORT", "entryPrice": ' + str.tostring(activeEntry) + ', "stopLoss": ' + str.tostring(activeEntry) + ', "takeProfit": ' + str.tostring(activeTp) + ', "breakeven": ' + str.tostring(breakeven) + ', "alertType": "BREAKEVEN", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(trade_id) + ', "mensaje": "Breakeven alcanzado - ' + str.tostring(math.round(breakeven_ratio * 100)) + '% profit, SL movido a entrada", "precio_actual": ' + str.tostring(close) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar)
    alert_breakeven_triggered := true
    label.new(bar_index, close, text="Breakeven\nID: " + str.tostring(trade_id), style=label.style_label_up, color=color.orange, textcolor=color.white, size=textSize)

// Track TP/SL for manual winrate (since strategy handles exits)
// Cuando en la misma vela se tocan TP y SL, priorizar STOP_LOSS (el exchange suele ejecutar el stop primero en barras vol√°tiles; evita incoherencia con Bitget)
bool long_tp_hit = high >= activeTp and activeTradeType == "LONG"
bool long_sl_hit = low <= activeStop and activeTradeType == "LONG"
bool long_both = long_tp_hit and long_sl_hit
bool long_sl_first = long_both
bool short_tp_hit = low <= activeTp and activeTradeType == "SHORT"
bool short_sl_hit = high >= activeStop and activeTradeType == "SHORT"
bool short_both = short_tp_hit and short_sl_hit
bool short_sl_first = short_both

// SHORT: ambos en misma vela -> priorizar seg√∫n open; si no, TP o SL por separado
if short_both
    if short_sl_first and not alert_stop_loss_triggered
        string multi_tf_json = buildMultiTimeframeJSON()
        alert('{"symbol": "' + syminfo.ticker + '", "side": "SHORT", "entryPrice": ' + str.tostring(activeEntry) + ', "stopLoss": ' + str.tostring(activeStop) + ', "takeProfit": ' + str.tostring(activeTp) + ', "breakeven": ' + str.tostring(breakeven) + ', "alertType": "STOP_LOSS", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(trade_id) + ', "mensaje": "El trade llego a stop loss", "precio_actual": ' + str.tostring(close) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar_close)
        alert_stop_loss_triggered := true
        alert_take_profit_triggered := true
        if alert_breakeven_triggered
            array.push(outcomes, 1.0)
        else
            array.push(outcomes, 0.0)
        if array.size(outcomes) > num_ops
            array.shift(outcomes)
        op := "na"
        breakeven := 0.0
        isTradeOpen := false
        activeTradeType := "na"
        limits := 0.0
        tps := 0.0
        stops := 0.0
        alert_breakeven_triggered := false
        label.new(bar_index, high, text="Stop Loss\nID: " + str.tostring(trade_id), style=label.style_label_down, color=color.red, textcolor=color.white, size=textSize)
    else if not short_sl_first and not alert_take_profit_triggered
        string multi_tf_json = buildMultiTimeframeJSON()
        alert('{"symbol": "' + syminfo.ticker + '", "side": "SHORT", "entryPrice": ' + str.tostring(activeEntry) + ', "stopLoss": ' + str.tostring(activeStop) + ', "takeProfit": ' + str.tostring(activeTp) + ', "breakeven": ' + str.tostring(breakeven) + ', "alertType": "TAKE_PROFIT", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(trade_id) + ', "mensaje": "El trade llego a take profit", "precio_actual": ' + str.tostring(close) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar_close)
        alert_take_profit_triggered := true
        alert_stop_loss_triggered := true
        op := "na"
        breakeven := 0.0
        isTradeOpen := false
        activeTradeType := "na"
        limits := 0.0
        tps := 0.0
        stops := 0.0
        array.push(outcomes, 1.0)
        if array.size(outcomes) > num_ops
            array.shift(outcomes)
        alert_breakeven_triggered := false
        label.new(bar_index, low, text="Take Profit\nID: " + str.tostring(trade_id), style=label.style_label_down, color=color.green, textcolor=color.white, size=textSize)
else if short_tp_hit and not alert_take_profit_triggered
    string multi_tf_json = buildMultiTimeframeJSON()
    alert('{"symbol": "' + syminfo.ticker + '", "side": "SHORT", "entryPrice": ' + str.tostring(activeEntry) + ', "stopLoss": ' + str.tostring(activeStop) + ', "takeProfit": ' + str.tostring(activeTp) + ', "breakeven": ' + str.tostring(breakeven) + ', "alertType": "TAKE_PROFIT", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(trade_id) + ', "mensaje": "El trade llego a take profit", "precio_actual": ' + str.tostring(close) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar_close)
    alert_take_profit_triggered := true
    alert_stop_loss_triggered := true
    op := "na"
    breakeven := 0.0
    isTradeOpen := false
    activeTradeType := "na"
    limits := 0.0
    tps := 0.0
    stops := 0.0
    array.push(outcomes, 1.0)
    if array.size(outcomes) > num_ops
        array.shift(outcomes)
    alert_breakeven_triggered := false
    label.new(bar_index, low, text="Take Profit\nID: " + str.tostring(trade_id), style=label.style_label_down, color=color.green, textcolor=color.white, size=textSize)
else if short_sl_hit and not alert_stop_loss_triggered
    string multi_tf_json = buildMultiTimeframeJSON()
    alert('{"symbol": "' + syminfo.ticker + '", "side": "SHORT", "entryPrice": ' + str.tostring(activeEntry) + ', "stopLoss": ' + str.tostring(activeStop) + ', "takeProfit": ' + str.tostring(activeTp) + ', "breakeven": ' + str.tostring(breakeven) + ', "alertType": "STOP_LOSS", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(trade_id) + ', "mensaje": "El trade llego a stop loss", "precio_actual": ' + str.tostring(close) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar_close)
    alert_stop_loss_triggered := true
    alert_take_profit_triggered := true
    if alert_breakeven_triggered
        array.push(outcomes, 1.0)
    else
        array.push(outcomes, 0.0)
    if array.size(outcomes) > num_ops
        array.shift(outcomes)
    op := "na"
    breakeven := 0.0
    isTradeOpen := false
    activeTradeType := "na"
    limits := 0.0
    tps := 0.0
    stops := 0.0
    alert_breakeven_triggered := false
    label.new(bar_index, high, text="Stop Loss\nID: " + str.tostring(trade_id), style=label.style_label_down, color=color.red, textcolor=color.white, size=textSize)

// LONG: ambos en misma vela -> priorizar SL si open <= mid (precio baj√≥ primero), sino TP
if long_both
    if long_sl_first and not alert_stop_loss_triggered
        string multi_tf_json = buildMultiTimeframeJSON()
        alert('{"symbol": "' + syminfo.ticker + '", "side": "LONG", "entryPrice": ' + str.tostring(activeEntry) + ', "stopLoss": ' + str.tostring(activeStop) + ', "takeProfit": ' + str.tostring(activeTp) + ', "breakeven": ' + str.tostring(breakeven) + ', "alertType": "STOP_LOSS", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(trade_id) + ', "mensaje": "El trade llego a stop loss", "precio_actual": ' + str.tostring(close) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar_close)
        alert_stop_loss_triggered := true
        alert_take_profit_triggered := true
        if alert_breakeven_triggered
            array.push(outcomes, 1.0)
        else
            array.push(outcomes, 0.0)
        if array.size(outcomes) > num_ops
            array.shift(outcomes)
        op := "na"
        breakeven := 0.0
        isTradeOpen := false
        activeTradeType := "na"
        limitl := 0.0
        tpl := 0.0
        stopl := 0.0
        alert_breakeven_triggered := false
        label.new(bar_index, low, text="Stop Loss\nID: " + str.tostring(trade_id), style=label.style_label_up, color=color.red, textcolor=color.white, size=textSize)
    else if not long_sl_first and not alert_take_profit_triggered
        string multi_tf_json = buildMultiTimeframeJSON()
        alert('{"symbol": "' + syminfo.ticker + '", "side": "LONG", "entryPrice": ' + str.tostring(activeEntry) + ', "stopLoss": ' + str.tostring(activeStop) + ', "takeProfit": ' + str.tostring(activeTp) + ', "breakeven": ' + str.tostring(breakeven) + ', "alertType": "TAKE_PROFIT", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(trade_id) + ', "mensaje": "El trade llego a take profit", "precio_actual": ' + str.tostring(close) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar_close)
        alert_take_profit_triggered := true
        alert_stop_loss_triggered := true
        op := "na"
        breakeven := 0.0
        isTradeOpen := false
        activeTradeType := "na"
        limitl := 0.0
        tpl := 0.0
        stopl := 0.0
        array.push(outcomes, 1.0)
        if array.size(outcomes) > num_ops
            array.shift(outcomes)
        alert_breakeven_triggered := false
        label.new(bar_index, high, text="Take Profit\nID: " + str.tostring(trade_id), style=label.style_label_up, color=color.green, textcolor=color.white, size=textSize)
else if long_tp_hit and not alert_take_profit_triggered
    string multi_tf_json = buildMultiTimeframeJSON()
    alert('{"symbol": "' + syminfo.ticker + '", "side": "LONG", "entryPrice": ' + str.tostring(activeEntry) + ', "stopLoss": ' + str.tostring(activeStop) + ', "takeProfit": ' + str.tostring(activeTp) + ', "breakeven": ' + str.tostring(breakeven) + ', "alertType": "TAKE_PROFIT", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(trade_id) + ', "mensaje": "El trade llego a take profit", "precio_actual": ' + str.tostring(close) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar_close)
    alert_take_profit_triggered := true
    alert_stop_loss_triggered := true
    op := "na"
    breakeven := 0.0
    isTradeOpen := false
    activeTradeType := "na"
    limitl := 0.0
    tpl := 0.0
    stopl := 0.0
    array.push(outcomes, 1.0)
    if array.size(outcomes) > num_ops
        array.shift(outcomes)
    alert_breakeven_triggered := false
    label.new(bar_index, high, text="Take Profit\nID: " + str.tostring(trade_id), style=label.style_label_up, color=color.green, textcolor=color.white, size=textSize)
else if long_sl_hit and not alert_stop_loss_triggered
    string multi_tf_json = buildMultiTimeframeJSON()
    alert('{"symbol": "' + syminfo.ticker + '", "side": "LONG", "entryPrice": ' + str.tostring(activeEntry) + ', "stopLoss": ' + str.tostring(activeStop) + ', "takeProfit": ' + str.tostring(activeTp) + ', "breakeven": ' + str.tostring(breakeven) + ', "alertType": "STOP_LOSS", "strategy": "Auto Trading Estrategy V1", "timeframe": "' + timeframe.period + '", "alertData": {"id": ' + str.tostring(trade_id) + ', "mensaje": "El trade llego a stop loss", "precio_actual": ' + str.tostring(close) + ', "rsi": ' + str.tostring(rsi) + ', "macd": {"line": ' + str.tostring(macd_line) + ', "signal": ' + str.tostring(signal_line) + ', "hist": ' + str.tostring(hist) + '}, "ema": ' + str.tostring(ema1) + ', "atr": ' + str.tostring(atrValue) + ', "volume": ' + str.tostring(vol) + ', "pivots": {"high": ' + str.tostring(M_HIGH) + ', "low": ' + str.tostring(M_LOW) + ', "med": ' + str.tostring(M_MED) + '}, "currentPrice": ' + str.tostring(close) + ', ' + multi_tf_json + '}}', alert.freq_once_per_bar_close)
    alert_stop_loss_triggered := true
    alert_take_profit_triggered := true
    if alert_breakeven_triggered
        array.push(outcomes, 1.0)
    else
        array.push(outcomes, 0.0)
    if array.size(outcomes) > num_ops
        array.shift(outcomes)
    op := "na"
    breakeven := 0.0
    isTradeOpen := false
    activeTradeType := "na"
    limitl := 0.0
    tpl := 0.0
    stopl := 0.0
    alert_breakeven_triggered := false
    label.new(bar_index, low, text="Stop Loss\nID: " + str.tostring(trade_id), style=label.style_label_up, color=color.red, textcolor=color.white, size=textSize)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üìä VISUALIZACI√ìN (MANTENIENDO EL DISE√ëO ORIGINAL)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Plot de las condiciones RSI
plotshape(sc, style=shape.triangledown, location=location.top, color=color.red, size=size.tiny)
plotshape(sv, style=shape.triangleup, location=location.bottom, color=color.green, size=size.tiny)

// Plot breakeven
plot(isTradeOpen ? breakeven : na, "Breakeven", color=color.orange, style=plot.style_linebr, linewidth=1)

// Plots de niveles de entrada, TP y SL
medios = plot(pupupu and limits > 0.0 ? limits : na, title="Entry Point Short", style=plot.style_linebr, color=color.rgb(255, 255, 30, 50), linewidth=1)
ganancias = plot(tpc and tps > 0.0 ? tps : na, title="TP-1 Short", style=plot.style_linebr, color=color.rgb(17, 84, 64, 65), linewidth=1)
perdidas = plot(tpc and stops > 0.0 ? stops : na, title="Stop Short", style=plot.style_linebr, color=color.rgb(244, 42, 42, 80), linewidth=1)
fill(medios, ganancias, color=color.rgb(17, 84, 64, 65))
fill(medios, perdidas, color=color.rgb(224, 42, 42, 80))

mediol = plot(pupupu and limitl > 0.0 ? limitl : na, title="Entry Point Long", style=plot.style_linebr, color=color.rgb(255, 255, 30, 50), linewidth=1)
ganancial = plot(tpc and tpl > 0.0 ? tpl : na, title="TP-1 Long", style=plot.style_linebr, color=color.rgb(17, 84, 64, 65), linewidth=1)
perdidal = plot(tpc and stopl > 0.0 ? stopl : na, title="Stop Long", style=plot.style_linebr, color=color.rgb(244, 42, 42, 80), linewidth=1)
fill(mediol, ganancial, color=color.rgb(17, 84, 64, 65))
fill(mediol, perdidal, color=color.rgb(224, 42, 42, 85))

// Tabla de informaci√≥n
mysite = "AutoTrading Improved"
var infoTable = table.new(position=position.bottom_right, columns=1, rows=11, bgcolor=color.rgb(208, 207, 198), border_width=2)
table.cell(infoTable, 0, 0, text=mysite, text_halign=text.align_center, text_size=textSize, text_color=chart.bg_color, bgcolor=chart.fg_color)
table.cell(infoTable, 0, 1, text=op + " " + syminfo.ticker + "‚ñê RR 1:" + str.tostring(take_profit) + "‚ñê " + str.tostring(SML_Channel_TF_mins_D_W_M), text_size=textSize, text_halign=text.align_left, text_color=color.fuchsia, bgcolor=chart.bg_color)
table.cell(infoTable, 0, 2, text="ENTRADA : " + str.tostring(math.round(limit, DEC)), text_size=textSize, text_halign=text.align_left, text_color=color.yellow, bgcolor=chart.bg_color)
table.cell(infoTable, 0, 3, text="STOP : " + str.tostring(math.round(stop, DEC)), text_size=textSize, text_halign=text.align_left, text_color=color.red, bgcolor=chart.bg_color)
table.cell(infoTable, 0, 4, text="TP-1 : " + str.tostring(math.round(tp, DEC)), text_size=textSize, text_halign=text.align_left, text_color=color.green, bgcolor=chart.bg_color)
table.cell(infoTable, 0, 5, text="LOTE : " + str.tostring(math.round(LOTE, 5)) + "‚ñê $ " + str.tostring(math.round(POSICION, 2)), text_size=textSize, text_halign=text.align_left, text_color=tema == "Oscuro" ? color.rgb(250, 250, 250) : color.rgb(0, 0, 0), bgcolor=chart.bg_color)
table.cell(infoTable, 0, 6, text="COMISI√ìN: ‚ñê " + str.tostring(math.round(COMI, 4)) + " ‚ñê ", text_size=textSize, text_halign=text.align_left, text_color=tema == "Oscuro" ? color.rgb(250, 250, 250) : color.rgb(0, 0, 0), bgcolor=chart.bg_color)
table.cell(infoTable, 0, 7, text="Trade ID: " + str.tostring(trade_id), text_size=textSize, text_halign=text.align_left, text_color=color.blue, bgcolor=chart.bg_color)

// Winrate (usando built-in de strategy)
winrate = strategy.closedtrades > 0 ? (strategy.wintrades / strategy.closedtrades) * 100 : 0.0
table.cell(infoTable, 0, 8, text="Winrate : " + str.tostring(math.round(winrate, 2)) + "%", text_size=textSize, text_halign=text.align_left, text_color=winrate >= 50 ? color.green : color.red, bgcolor=chart.bg_color)

// Adjusted Winrate
adjusted_winrate = array.size(outcomes) > 0 ? (array.sum(outcomes) / array.size(outcomes)) * 100 : 0.0
table.cell(infoTable, 0, 9, text="Winrate Adjusted (incl. BE): " + str.tostring(math.round(adjusted_winrate, 2)) + "%", text_size=textSize, text_halign=text.align_left, text_color=adjusted_winrate >= 50 ? color.green : color.red, bgcolor=chart.bg_color)

// Sentimiento
var sentimiento = rsi_alcista ? "ALCISTA" : rsi_bajista ? "BAJISTA" : "NEUTRAL"
table.cell(infoTable, 0, 10, text="SENTIMIENTO: " + sentimiento, text_size=textSize, text_halign=text.align_left, text_color=sentimiento == "ALCISTA" ? color.green : sentimiento == "BAJISTA" ? color.red : color.gray, bgcolor=chart.bg_color)